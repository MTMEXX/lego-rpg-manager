<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>LEGO RPG Manager - Crea Personaggio</title>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600&display=swap" rel="stylesheet">
<style>
:root{
  --lego-yellow:#f7d23e; --lego-red:#e53e3e; --lego-blue:#3182ce; --lego-gray:#f8f8f8;
}
body{margin:0;font-family:Montserrat, sans-serif;background:var(--lego-gray);color:#222;}
header{background:var(--lego-yellow);padding:18px;text-align:center;font-weight:800;color:var(--lego-red);box-shadow:0 4px 10px rgba(0,0,0,.15);}
main{max-width:1000px;margin:24px auto;background:#fff;border-radius:14px;padding:28px;box-shadow:0 6px 20px rgba(0,0,0,.08);}
label{display:block;font-weight:600;margin-top:12px;}
select,input[type="text"],input[type="number"]{width:100%;padding:10px;border-radius:8px;border:1px solid #ccc;margin-top:6px;}
.stat-row{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;padding:6px 4px;border-bottom:1px solid #f0f0f0;}
.stat-row input{width:84px;text-align:center;}
#modTable,#pgTable{width:100%;border-collapse:collapse;margin-top:12px;}
#modTable th,#modTable td,#pgTable th,#pgTable td{border:1px solid #ddd;padding:8px;text-align:center;}
#modTable th,#pgTable th{background:var(--lego-yellow);}
.controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px;}
.btn{background:var(--lego-blue);color:white;border:none;padding:10px 14px;border-radius:8px;font-weight:700;cursor:pointer;}
.btn.red{background:var(--lego-red);}
.footer-buttons{text-align:center;margin-top:18px;}
small.note{color:#666}
</style>
</head>
<body>
<header>LEGO RPG Manager — Crea Personaggio</header>

<main>
  <h2>Dati Personaggio</h2>

  <label>Nome</label>
  <input id="pgNome" type="text" placeholder="Nome personaggio">

  <label>Specie</label>
  <select id="selSpecie"></select>

  <label>Classe</label>
  <select id="selClasse"></select>

  <label>Multiverso</label>
  <select id="selMulti"></select>

  <label>Livello</label>
  <select id="selLivello"></select>

  <label>Grado</label>
  <select id="selGrado" onchange="onGradoChange()"></select>

  <p><small class="note">Il valore "BUDGET PUNTI STATISTICHE INIZIALI" viene letto dalla colonna del CSV dei gradi.</small></p>

  <h3 style="margin-top:18px">Statistiche primarie (distribuisci i punti)</h3>
  <p>Punti disponibili: <strong id="puntiDisponibili">0</strong> — usati: <strong id="puntiUsati">0</strong></p>
  <div id="statContainer"></div>

  <h3>Modificatori (in tempo reale)</h3>
  <table id="modTable"><tr><th>Stat</th><th>Modificatore</th></tr></table>

  <div style="margin-top:16px" class="controls">
    <button class="btn" onclick="aggiungiPG()">➕ Aggiungi PG</button>
    <button class="btn" onclick="scaricaCSV()">⬇ Scarica pg-database.csv</button>
    <button class="btn red" onclick="resetNuovi()">Reset nuovi</button>
  </div>

  <h3 style="margin-top:22px">PG (esistenti + nuovi)</h3>
  <table id="pgTable">
    <tr><th>ID</th><th>NOME</th><th>SPECIE(ID)</th><th>CLASSE(ID)</th><th>MULTI(ID)</th><th>LV(ID)</th><th>GRADO(ID)</th><!-- stat headers aggiunti dinamicamente --></tr>
  </table>
</main>

<script>
/*
  Robust create-pg page:
  - parses ; separated CSV (handles quotes lightly)
  - uses header normalization to find needed columns
  - populates selects showing only NOME column
  - renders stat inputs and calculates modifiers live:
      base = floor((stat - 10)/2)
      final = base + specieMod + classeMod
  - collects existing pg-database if present, computes next ID
  - lets you add multiple PG and download merged CSV
*/

// --- config: base path to your db folder raw github
const BASE = "https://raw.githubusercontent.com/MTMEXX/lego-rpg-manager/refs/heads/main/db/";

// filenames expected (as you confirmed)
const FILES = {
  speci: "speci.csv",
  classi: "classi.csv",
  multiversi: "multiversi-pg.csv",
  livelli: "livelli.csv",
  gradi: "gradi.csv",
  stats: "statistiche_primarie.csv",
  pgdb: "pg-database.csv"
};

// storage
let SPECIE = [], CLASSI = [], MULTI = [], LIVELLI = [], GRADI = [], STATS = [], PGDB = [];
let NUOVI_PG = []; // array of arrays for CSV rows (will be appened)
let headerMap = {}; // for pg-database existing header if needed
let statNames = [];

// UTIL: parse CSV line with semicolon, rudimentary handling of quotes
function splitSemicolonSafe(line) {
  const out = [];
  let cur = "";
  let inQuote = false;
  for (let i=0;i<line.length;i++){
    const ch = line[i];
    if (ch === '"' ) {
      inQuote = !inQuote;
      continue; // remove quotes
    }
    if (!inQuote && ch === ';') {
      out.push(cur);
      cur = "";
    } else {
      cur += ch;
    }
  }
  out.push(cur);
  return out.map(s => s.trim());
}

// Parse entire CSV text: returns array of rows (each row array of columns)
function parseCSVSemicolon(text){
  const lines = text.replace(/\r/g,"").split("\n").filter(l=>l.trim()!=="");
  const rows = lines.map(l => splitSemicolonSafe(l));
  return rows;
}

// fetch+parse helper
async function fetchCSV(name){
  try {
    const r = await fetch(BASE + name);
    if (!r.ok) {
      // console.warn("file not found:", name);
      return null;
    }
    const txt = await r.text();
    return parseCSVSemicolon(txt);
  } catch(e){
    console.error("fetch error", e);
    return null;
  }
}

// normalize header key (remove spaces, underscores, lowercase)
function norm(h) {
  return h ? h.toString().replace(/[^a-zA-Z0-9]/g,"").toLowerCase() : "";
}

// build map from header row array
function buildHeaderMap(headerRow) {
  const m = {};
  headerRow.forEach((h,i)=> m[norm(h)] = i);
  return m;
}

// fill a select element with rows: uses column "nome" (case-insensitive)
function fillSelectFromRows(selId, rows) {
  const sel = document.getElementById(selId);
  sel.innerHTML = "<option value=''>-- Seleziona --</option>";
  if (!rows) return;
  // header may be included? our parse returns all rows; assume first row is header if it contains text 'nome' at some column
  let header = rows[0];
  let startIndex = 0;
  if (header && header.some(c => c && c.toLowerCase().includes("nome"))) {
    // skip header row
    startIndex = 1;
  }
  for (let i = startIndex; i < rows.length; i++){
    const r = rows[i];
    if (!r) continue;
    const id = r[0] || "";
    const name = r[1] || r[2] || r[0] || "";
    sel.add(new Option(name, id));
  }
}

// read modifier arrays from a row using normalized keys
// expected: specie rows have columns "Mod _for", "Mod_des", ... but names vary; we rely on header mapping
function getModifierArrayFromRow(row, headerMapRow) {
  // headerMapRow maps normalized header->index
  // mapping we expect (from your header description):
  // specie: Mod _for (col F), Mod_des (G), Mod_cos(H), Mod_int(I), Mod_sag(J), Mod_car(K)
  // classi: Mod _for (K), Mod_des(L), Mod_cos(M), Mod_int(N), Mod_sag(O), Mod_car(P)
  // But to be robust, we'll look for keys containing 'mod'+'for' etc.
  const keys = Object.keys(headerMapRow);
  const lookup = name => {
    // try direct normalized name
    const n = norm(name);
    if (n in headerMapRow) return headerMapRow[n];
    // try find by contains
    const found = keys.find(k => k.includes(name.replace(/[^a-zA-Z]/g,"").toLowerCase()));
    return found ? headerMapRow[found] : -1;
  };
  const idxFor = lookup("modfor") !== -1 ? lookup("modfor") : lookup("mod_for");
  const idxDes = lookup("moddes") !== -1 ? lookup("moddes") : lookup("mod_des");
  const idxCos = lookup("modcos") !== -1 ? lookup("modcos") : lookup("mod_cos");
  const idxInt = lookup("modint") !== -1 ? lookup("modint") : lookup("mod_int");
  const idxSag = lookup("modsag") !== -1 ? lookup("modsag") : lookup("mod_sag");
  const idxCar = lookup("modcar") !== -1 ? lookup("modcar") : lookup("mod_car");

  const arr = [];
  arr.push(idxFor>=0 ? Number(row[idxFor]||0) : 0);
  arr.push(idxDes>=0 ? Number(row[idxDes]||0) : 0);
  arr.push(idxCos>=0 ? Number(row[idxCos]||0) : 0);
  arr.push(idxInt>=0 ? Number(row[idxInt]||0) : 0);
  arr.push(idxSag>=0 ? Number(row[idxSag]||0) : 0);
  arr.push(idxCar>=0 ? Number(row[idxCar]||0) : 0);
  return arr;
}

// ---- main init
(async function mainInit(){
  // fetch all CSVs (returns array-of-rows including header)
  const [
    rawSpecie, rawClassi, rawMulti, rawLivelli, rawGradi, rawStats, rawPGDB
  ] = await Promise.all([
    fetchCSV(FILES.speci),
    fetchCSV(FILES.classi),
    fetchCSV(FILES.multiversi),
    fetchCSV(FILES.livelli),
    fetchCSV(FILES.gradi),
    fetchCSV(FILES.stats),
    fetchCSV(FILES.pgdb)
  ]);

  // store raw arrays
  SPECIE = rawSpecie || [];
  CLASSI = rawClassi || [];
  MULTI = rawMulti || [];
  LIVELLI = rawLivelli || [];
  GRADI = rawGradi || [];
  STATS = rawStats || [];
  PGDB = rawPGDB || [];

  // build header maps for specie/classi/gradi etc (if present)
  const specieHeaderMap = SPECIE.length ? buildHeaderMap(SPECIE[0]) : {};
  const classiHeaderMap = CLASSI.length ? buildHeaderMap(CLASSI[0]) : {};
  const gradiHeaderMap = GRADI.length ? buildHeaderMap(GRADI[0]) : {};
  const statsHeaderMap = STATS.length ? buildHeaderMap(STATS[0]) : {};
  const pgHeaderMap = PGDB.length ? buildHeaderMap(PGDB[0]) : {};

  // remove header rows from arrays for simpler handling but keep header maps
  if (SPECIE.length && SPECIE[0].some(c => (c||"").toLowerCase().includes("nome"))) SPECIE = SPECIE.slice(1);
  if (CLASSI.length && CLASSI[0].some(c => (c||"").toLowerCase().includes("nome"))) CLASSI = CLASSI.slice(1);
  if (MULTI.length && MULTI[0].some(c => (c||"").toLowerCase().includes("nome"))) MULTI = MULTI.slice(1);
  if (LIVELLI.length && LIVELLI[0].some(c => (c||"").toLowerCase().includes("nome"))) LIVELLI = LIVELLI.slice(1);
  if (GRADI.length && GRADI[0].some(c => (c||"").toLowerCase().includes("nome"))) GRADI = GRADI.slice(1);
  if (STATS.length && STATS[0].some(c => (c||"").toLowerCase().includes("nome"))) STATS = STATS.slice(1);
  if (PGDB.length && PGDB[0].some(c => (c||"").toLowerCase().includes("nome"))) PGDB = PGDB.slice(1);

  // stat names
  statNames = STATS.map(r => r[1] || r[0]);

  // fill selects (only show Nome)
  function fillSelectFromRaw(selId, raw, headerMap){
    const sel = document.getElementById(selId);
    sel.innerHTML = "<option value=''>-- Seleziona --</option>";
    raw.forEach(r => {
      const id = r[0] || "";
      const name = r[1] || id;
      sel.add(new Option(name, id));
    });
  }

  fillSelectFromRaw("selSpecie", SPECIE, specieHeaderMap);
  fillSelectFromRaw("selClasse", CLASSI, classiHeaderMap);
  fillSelectFromRaw("selMulti", MULTI, {});
  fillSelectFromRaw("selLivello", LIVELLI, {});
  fillSelectFromRaw("selGrado", GRADI, {});

  // render stat inputs
  renderStatInputs();

  // build initial PG table (existing PGs read from pg-database if present)
  buildPGTable();

  // attach listeners to recalc modifiers on select changes
  ["selSpecie","selClasse"].forEach(id=>{
    document.getElementById(id).addEventListener("change", updateAllModifiers);
  });
})();

// render stat inputs area
function renderStatInputs(){
  const cont = document.getElementById("statContainer");
  cont.innerHTML = "";
  statNames.forEach((s, idx)=>{
    const div = document.createElement("div");
    div.className = "stat-row";
    div.innerHTML = `<div style="flex:1">${s}</div>
      <div style="width:96px"><input type="number" min="0" value="0" data-idx="${idx}" onchange="onStatChange(event)"></div>`;
    cont.appendChild(div);
  });
  // reset points info
  document.getElementById("puntiDisponibili").textContent = "0";
  document.getElementById("puntiUsati").textContent = "0";
}

// when selecting a grado, update points available (uses GRADI header)
function onGradoChange(){
  // find selected grado row
  const selVal = document.getElementById("selGrado").value;
  let punti = 0;
  // GRADI structure: header includes "BUDGET PUNTI STATISTICHE INIZIALI" in column D (index 3),
  // but to be robust search header names
  if (GRADI && GRADI.length){
    // find header index by normalizing header row from the original raw (if we had header)
    // We don't have header now since we sliced, but we can infer field by position per your description:
    // ID (0), NOME (1), DESCRIZIONE (2), BUDGET... (3)
    const found = GRADI.find(r => r[0] === selVal);
    if (found) {
      punti = Number(found[3] || 0);
    }
  }
  document.getElementById("puntiDisponibili").textContent = punti;
  document.getElementById("puntiUsati").textContent = 0;
  // reset stat inputs to 0
  document.querySelectorAll("#statContainer input").forEach(i => i.value = 0);
  updateAllModifiers();
}

// stat change handler
function onStatChange(e){
  // recalc used points
  const inputs = Array.from(document.querySelectorAll("#statContainer input"));
  const used = inputs.reduce((s,i)=> s + (Number(i.value) || 0), 0);
  const avail = Number(document.getElementById("puntiDisponibili").textContent) || 0;
  if (used > avail){
    // prevent over-assign
    alert("Hai superato i punti disponibili!");
    e.target.value = 0;
    return onStatChange(e);
  }
  document.getElementById("puntiUsati").textContent = used;
  updateAllModifiers();
}

// compute modifier base for a stat value
function baseModifier(statValue){
  const v = Number(statValue) || 0;
  return Math.floor((v - 10)/2);
}

// helper to get modifier arrays for selected specie/class (6 values order: for,des,cos,int,sag,car)
function getSpecieMods(){
  const sel = document.getElementById("selSpecie").value;
  if (!SPECIE || !SPECIE.length) return [0,0,0,0,0,0];
  const found = SPECIE.find(r => r[0] === sel);
  if (!found) return [0,0,0,0,0,0];
  // from your header: speci columns: ID(0), NOME(1), Mod_PV_Base(2), Mod_PE_Base(3), Mod_PS_Base(4), Mod _for(5), Mod_des(6), Mod_cos(7), Mod_int(8), Mod_sag(9), Mod_car(10)
  // so modifiers start at index 5..10
  const mods = [];
  for (let i=5;i<=10;i++){
    mods.push(Number(found[i] || 0));
  }
  return mods;
}
function getClasseMods(){
  const sel = document.getElementById("selClasse").value;
  if (!CLASSI || !CLASSI.length) return [0,0,0,0,0,0];
  const found = CLASSI.find(r => r[0] === sel);
  if (!found) return [0,0,0,0,0,0];
  // from classi header: ID(0),NOME(1),DESCR(2),PV base(3),PE(4),PS(5),VEL(6),GUIDA(7),COMP(8),TTIPO(9),Mod_for(10),Mod_des(11),Mod_cos(12),Mod_int(13),Mod_sag(14),Mod_car(15)
  const mods=[];
  for (let i=10;i<=15;i++){
    mods.push(Number(found[i] || 0));
  }
  return mods;
}

// update modifiers table
function updateAllModifiers(){
  const modTable = document.getElementById("modTable");
  // header
  modTable.innerHTML = "<tr><th>Stat</th><th>Modificatore Totale</th></tr>";
  const specieMods = getSpecieMods();
  const classeMods = getClasseMods();
  const inputs = Array.from(document.querySelectorAll("#statContainer input"));
  inputs.forEach((inp, idx) => {
    const statVal = Number(inp.value || 0);
    const base = baseModifier(statVal);
    const addSpec = Number(specieMods[idx] || 0);
    const addClass = Number(classeMods[idx] || 0);
    const tot = base + addSpec + addClass;
    modTable.innerHTML += `<tr><td>${statNames[idx] || ("STAT"+(idx+1))}</td><td>${tot >= 0 ? "+"+tot : tot}</td></tr>`;
  });
}

// build pg table with existing PGs (if any) and include stat headers
function buildPGTable(){
  const table = document.getElementById("pgTable");
  // clear and build header row
  const statCols = statNames.slice();
  const headerRow = ["ID","NOME","ID_SPECIE","ID_CLASSE","ID_MULTIVERSO","ID_LIVELLO","ID_GRADO",...statCols];
  table.innerHTML = "<tr>" + headerRow.map(h=>`<th>${h}</th>`).join("") + "</tr>";
  // existing PGDB rows if present (PGDB may include header we removed earlier)
  if (PGDB && PGDB.length){
    // if rows may include header, try to detect and ignore (we stripped earlier)
    PGDB.forEach(r => {
      // ensure row has enough columns; pad missing stat columns with ""
      const row = r.slice(0);
      while (row.length < headerRow.length) row.push("");
      table.innerHTML += "<tr>" + row.map(c=>`<td>${c}</td>`).join("") + "</tr>";
    });
  }
  // also list any newly created PGs
  NUOVI_PG.forEach(r => {
    const row = r.slice(0);
    while (row.length < headerRow.length) row.push("");
    table.innerHTML += "<tr>" + row.map(c=>`<td>${c}</td>`).join("") + "</tr>";
  });
}

// add newly created pg to NUOVI_PG and update table
function aggiungiPG(){
  const nome = document.getElementById("pgNome").value.trim();
  if (!nome) { alert("Inserisci il nome del personaggio"); return; }
  const specieId = document.getElementById("selSpecie").value || "";
  const classeId = document.getElementById("selClasse").value || "";
  const multiId = document.getElementById("selMulti").value || "";
  const lvId = document.getElementById("selLivello").value || "";
  const gradoId = document.getElementById("selGrado").value || "";
  // determine next ID: look at PGDB last row if exists, otherwise use existing NUOVI_PG length +1
  let lastId = 0;
  if (PGDB && PGDB.length) {
    // PGDB rows: first value is ID
    const ids = PGDB.map(r => Number(r[0]) || 0);
    lastId = Math.max(...ids, 0);
  }
  if (NUOVI_PG.length) {
    const ids2 = NUOVI_PG.map(r => Number(r[0]) || 0);
    lastId = Math.max(lastId, ...ids2);
  }
  const newId = lastId + 1;
  // collect stat values in same order as statNames
  const statValues = Array.from(document.querySelectorAll("#statContainer input")).map(i => Number(i.value || 0));
  // build row: ID;NOME;ID_SPECIE;ID_CLASSE;ID_MULTIVERSO;ID_LIVELLO;ID_GRADO;stat...
  const row = [String(newId), nome, specieId, classeId, multiId, lvId, gradoId, ...statValues.map(v=>String(v))];
  NUOVI_PG.push(row);
  // update table by re-building
  buildPGTable();
  // clear name field (keep selects)
  document.getElementById("pgNome").value = "";
  // reset stat inputs to zero and keep points allocation? We will reset to zero
  document.querySelectorAll("#statContainer input").forEach(i => i.value = 0);
  document.getElementById("puntiUsati").textContent = 0;
  updateAllModifiers();
}

// download merged CSV (existing PGDB + NUOVI_PG)
function scaricaCSV(){
  // prepare header: if PGDB had header originally we don't have it; we will create our own header:
  const headers = ["ID","NOME","ID_SPECIE","ID_CLASSE","ID_MULTIVERSO","ID_LIVELLO","ID_GRADO", ...statNames];
  const lines = [ headers.join(";") ];
  // add existing PGDB rows (PGDB already are arrays of columns)
  if (PGDB && PGDB.length){
    PGDB.forEach(r => {
      // ensure length = headers length
      const copy = r.slice(0);
      while (copy.length < headers.length) copy.push("");
      lines.push(copy.join(";"));
    });
  }
  // add new rows
  NUOVI_PG.forEach(r => {
    const copy = r.slice(0);
    while (copy.length < headers.length) copy.push("");
    lines.push(copy.join(";"));
  });
  const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8;' "});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "pg-database.csv";
  a.click();
}

// reset new PG list and UI
function resetNuovi(){
  if (!confirm("Resetta la lista dei nuovi PG aggiunti (solo quelli non salvati)?")) return;
  NUOVI_PG = [];
  buildPGTable();
}

// update modifiers on select/stat changes
function updateAllModifiers(){
  updateAllModifiersInternal();
}
function updateAllModifiersInternal(){
  // same implementation as above: compute specieMods and classeMods and base then render table
  const modTable = document.getElementById("modTable");
  modTable.innerHTML = "<tr><th>Stat</th><th>Modificatore Totale</th></tr>";
  const specieId = document.getElementById("selSpecie").value;
  const classeId = document.getElementById("selClasse").value;
  const specieRow = SPECIE.find(r => r[0] === specieId) || [];
  const classeRow = CLASSI.find(r => r[0] === classeId) || [];
  // specie modifiers expected at indexes 5..10, classi at 10..15 (per your header)
  const sMods = [];
  for (let i=5;i<=10;i++) sMods.push(Number(specieRow[i]||0));
  const cMods = [];
  for (let i=10;i<=15;i++) cMods.push(Number(classeRow[i]||0));
  const inputs = Array.from(document.querySelectorAll("#statContainer input"));
  inputs.forEach((inp, idx) => {
    const val = Number(inp.value || 0);
    const base = Math.floor((val - 10)/2);
    const tot = base + (Number(sMods[idx]||0)) + (Number(cMods[idx]||0));
    modTable.innerHTML += `<tr><td>${statNames[idx]||("STAT"+(idx+1))}</td><td>${tot >= 0 ? "+"+tot : tot}</td></tr>`;
  });
}

// logout helper
function logout(){ localStorage.removeItem("legoUser"); window.location.href = "index.html"; }

</script>
</body>
</html>
